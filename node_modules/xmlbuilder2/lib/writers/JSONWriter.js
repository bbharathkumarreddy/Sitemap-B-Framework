"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ObjectWriter_1 = require("./ObjectWriter");
const util_1 = require("@oozcitak/util");
const BaseWriter_1 = require("./BaseWriter");
/**
 * Serializes XML nodes into a JSON string.
 */
class JSONWriter extends BaseWriter_1.BaseWriter {
    /**
     * Produces an XML serialization of the given node.
     *
     * @param node - node to serialize
     * @param writerOptions - serialization options
     */
    serialize(node, writerOptions) {
        // provide default options
        const options = util_1.applyDefaults(writerOptions, {
            wellFormed: false,
            noDoubleEncoding: false,
            prettyPrint: false,
            indent: '  ',
            newline: '\n',
            offset: 0,
            group: false
        });
        // convert to object
        const objectWriterOptions = util_1.applyDefaults(options, {
            format: "object",
            wellFormed: false,
            noDoubleEncoding: false,
        });
        const objectWriter = new ObjectWriter_1.ObjectWriter(this._builderOptions);
        const val = objectWriter.serialize(node, objectWriterOptions);
        // recursively convert object into JSON string
        return this._beginLine(options, 0) + this._convertObject(val, options);
    }
    /**
     * Produces an XML serialization of the given object.
     *
     * @param obj - object to serialize
     * @param options - serialization options
     * @param level - depth of the XML tree
     */
    _convertObject(obj, options, level = 0) {
        let markup = '';
        const isLeaf = this._isLeafNode(obj);
        if (util_1.isArray(obj)) {
            markup += '[';
            const len = obj.length;
            let i = 0;
            for (const val of obj) {
                markup += this._endLine(options, level + 1) +
                    this._beginLine(options, level + 1) +
                    this._convertObject(val, options, level + 1);
                if (i < len - 1) {
                    markup += ',';
                }
                i++;
            }
            markup += this._endLine(options, level) + this._beginLine(options, level);
            markup += ']';
        }
        else if (util_1.isObject(obj)) {
            markup += '{';
            const len = util_1.objectLength(obj);
            let i = 0;
            util_1.forEachObject(obj, (key, val) => {
                if (isLeaf && options.prettyPrint) {
                    markup += ' ';
                }
                else {
                    markup += this._endLine(options, level + 1) + this._beginLine(options, level + 1);
                }
                markup += '"' + key + '":';
                if (options.prettyPrint) {
                    markup += ' ';
                }
                markup += this._convertObject(val, options, level + 1);
                if (i < len - 1) {
                    markup += ',';
                }
                i++;
            }, this);
            if (isLeaf && options.prettyPrint) {
                markup += ' ';
            }
            else {
                markup += this._endLine(options, level) + this._beginLine(options, level);
            }
            markup += '}';
        }
        else {
            markup += '"' + obj + '"';
        }
        return markup;
    }
    /**
     * Produces characters to be prepended to a line of string in pretty-print
     * mode.
     *
     * @param options - serialization options
     * @param level - current depth of the XML tree
     */
    _beginLine(options, level) {
        if (!options.prettyPrint) {
            return '';
        }
        else {
            const indentLevel = options.offset + level + 1;
            if (indentLevel > 0) {
                return new Array(indentLevel).join(options.indent);
            }
        }
        return '';
    }
    /**
     * Produces characters to be appended to a line of string in pretty-print
     * mode.
     *
     * @param options - serialization options
     * @param level - current depth of the XML tree
     */
    _endLine(options, level) {
        if (!options.prettyPrint) {
            return '';
        }
        else {
            return options.newline;
        }
    }
    /**
     * Determines if an object is a leaf node.
     *
     * @param obj
     */
    _isLeafNode(obj) {
        return this._descendantCount(obj) <= 1;
    }
    /**
     * Counts the number of descendants of the given object.
     *
     * @param obj
     * @param count
     */
    _descendantCount(obj, count = 0) {
        if (util_1.isArray(obj)) {
            util_1.forEachArray(obj, val => count += this._descendantCount(val, count), this);
        }
        else if (util_1.isObject(obj)) {
            util_1.forEachObject(obj, (key, val) => count += this._descendantCount(val, count), this);
        }
        else {
            count++;
        }
        return count;
    }
}
exports.JSONWriter = JSONWriter;
//# sourceMappingURL=JSONWriter.js.map