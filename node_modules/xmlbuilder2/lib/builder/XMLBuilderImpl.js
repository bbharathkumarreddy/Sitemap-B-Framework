"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const interfaces_1 = require("../interfaces");
const util_1 = require("@oozcitak/util");
const writers_1 = require("../writers");
const interfaces_2 = require("@oozcitak/dom/lib/dom/interfaces");
const util_2 = require("@oozcitak/dom/lib/util");
const algorithm_1 = require("@oozcitak/dom/lib/algorithm");
const dom_1 = require("./dom");
const infra_1 = require("@oozcitak/infra");
/**
 * Represents a wrapper that extends XML nodes to implement easy to use and
 * chainable document builder methods.
 */
class XMLBuilderImpl {
    /**
     * Initializes a new instance of `XMLBuilderNodeImpl`.
     *
     * @param domNode - the DOM node to wrap
     */
    constructor(domNode) {
        this._domNode = domNode;
    }
    /** @inheritdoc */
    get node() { return this._domNode; }
    /** @inheritdoc */
    set(options) {
        this._options = util_1.applyDefaults(util_1.applyDefaults(this._options, options, true), // apply user settings
        interfaces_1.DefaultBuilderOptions); // provide defaults
        return this;
    }
    /** @inheritdoc */
    ele(p1, p2, p3) {
        let namespace;
        let name;
        let attributes;
        let lastChild = null;
        if (util_1.isString(p1) && /^\s*</.test(p1)) {
            // parse XML string
            const contents = "<TEMP_ROOT>" + p1 + "</TEMP_ROOT>";
            const domParser = dom_1.createParser();
            const doc = domParser.parseFromString(dom_1.sanitizeInput(contents, this._options.invalidCharReplacement), "text/xml");
            /* istanbul ignore next */
            if (doc.documentElement === null) {
                throw new Error("Document element is null.");
            }
            dom_1.throwIfParserError(doc);
            for (const child of doc.documentElement.childNodes) {
                const newChild = doc.importNode(child, true);
                lastChild = new XMLBuilderImpl(newChild);
                this._domNode.appendChild(newChild);
            }
            if (lastChild === null) {
                throw new Error("Could not create any elements with: " + p1.toString() + ". " + this._debugInfo());
            }
            return lastChild;
        }
        else if (util_1.isString(p1) && /^\s*[\{\[]/.test(p1)) {
            // parse JSON string
            const obj = JSON.parse(p1);
            return this.ele(obj);
        }
        else if (util_1.isObject(p1)) {
            // ele(obj: ExpandObject)
            [namespace, name, attributes] = [undefined, p1, undefined];
        }
        else if ((p1 === null || util_1.isString(p1)) && util_1.isString(p2)) {
            // ele(namespace: string, name: string, attributes?: AttributesObject)
            [namespace, name, attributes] = [p1, p2, p3];
        }
        else if (p1 !== null) {
            // ele(name: string, attributes?: AttributesObject)
            [namespace, name, attributes] = [undefined, p1, util_1.isObject(p2) ? p2 : undefined];
        }
        else {
            throw new Error("Element name cannot be null. " + this._debugInfo());
        }
        if (attributes) {
            attributes = util_1.getValue(attributes);
        }
        if (util_1.isFunction(name)) {
            // evaluate if function
            lastChild = this.ele(name.apply(this));
        }
        else if (util_1.isArray(name) || util_1.isSet(name)) {
            util_1.forEachArray(name, item => lastChild = this.ele(item), this);
        }
        else if (util_1.isMap(name) || util_1.isObject(name)) {
            // expand if object
            util_1.forEachObject(name, (key, val) => {
                if (util_1.isFunction(val)) {
                    // evaluate if function
                    val = val.apply(this);
                }
                if (!this._options.ignoreConverters && key.indexOf(this._options.convert.att) === 0) {
                    // assign attributes
                    if (key === this._options.convert.att) {
                        lastChild = this.att(val);
                    }
                    else {
                        lastChild = this.att(key.substr(this._options.convert.att.length), val);
                    }
                }
                else if (!this._options.ignoreConverters && key.indexOf(this._options.convert.text) === 0) {
                    // text node
                    if (util_1.isMap(val) || util_1.isObject(val)) {
                        // if the key is #text expand child nodes under this node to support mixed content
                        lastChild = this.ele(val);
                    }
                    else {
                        lastChild = this.txt(val);
                    }
                }
                else if (!this._options.ignoreConverters && key.indexOf(this._options.convert.cdata) === 0) {
                    // cdata node
                    if (util_1.isArray(val) || util_1.isSet(val)) {
                        util_1.forEachArray(val, item => lastChild = this.dat(item), this);
                    }
                    else {
                        lastChild = this.dat(val);
                    }
                }
                else if (!this._options.ignoreConverters && key.indexOf(this._options.convert.comment) === 0) {
                    // comment node
                    if (util_1.isArray(val) || util_1.isSet(val)) {
                        util_1.forEachArray(val, item => lastChild = this.com(item), this);
                    }
                    else {
                        lastChild = this.com(val);
                    }
                }
                else if (!this._options.ignoreConverters && key.indexOf(this._options.convert.ins) === 0) {
                    // processing instruction
                    if (util_1.isString(val)) {
                        const insIndex = val.indexOf(' ');
                        const insTarget = (insIndex === -1 ? val : val.substr(0, insIndex));
                        const insValue = (insIndex === -1 ? '' : val.substr(insIndex + 1));
                        lastChild = this.ins(insTarget, insValue);
                    }
                    else {
                        lastChild = this.ins(val);
                    }
                }
                else if ((util_1.isArray(val) || util_1.isSet(val)) && util_1.isEmpty(val)) {
                    // skip empty arrays
                    lastChild = this._dummy();
                }
                else if ((util_1.isMap(val) || util_1.isObject(val)) && util_1.isEmpty(val)) {
                    // empty objects produce one node
                    lastChild = this.ele(key);
                }
                else if (!this._options.keepNullNodes && (val == null)) {
                    // skip null and undefined nodes
                    lastChild = this._dummy();
                }
                else if (util_1.isArray(val) || util_1.isSet(val)) {
                    // expand list by creating child nodes
                    util_1.forEachArray(val, item => {
                        const childNode = {};
                        childNode[key] = item;
                        lastChild = this.ele(childNode);
                    }, this);
                }
                else if (util_1.isMap(val) || util_1.isObject(val)) {
                    // create a parent node
                    lastChild = this.ele(key);
                    // expand child nodes under parent
                    lastChild.ele(val);
                }
                else if (val) {
                    // leaf element node with a single text node
                    lastChild = this.ele(key);
                    lastChild.txt(val);
                }
                else {
                    // leaf element node
                    lastChild = this.ele(key);
                }
            }, this);
        }
        else {
            [namespace, name] = this._extractNamespace(dom_1.sanitizeInput(namespace, this._options.invalidCharReplacement), dom_1.sanitizeInput(name, this._options.invalidCharReplacement), true);
            // inherit namespace from parent
            if (namespace === undefined) {
                const [prefix] = algorithm_1.namespace_extractQName(name);
                namespace = this.node.lookupNamespaceURI(prefix);
            }
            // create a child element node
            const childNode = (namespace !== undefined && namespace !== null ?
                this._doc.createElementNS(namespace, name) :
                this._doc.createElement(name));
            this.node.appendChild(childNode);
            lastChild = new XMLBuilderImpl(childNode);
            // update doctype node if the new node is the document element node
            const oldDocType = this._doc.doctype;
            if (childNode === this._doc.documentElement && oldDocType !== null) {
                const docType = this._doc.implementation.createDocumentType(this._doc.documentElement.tagName, oldDocType.publicId, oldDocType.systemId);
                this._doc.replaceChild(docType, oldDocType);
            }
            // create attributes
            if (attributes && !util_1.isEmpty(attributes)) {
                lastChild.att(attributes);
            }
        }
        if (lastChild === null) {
            throw new Error("Could not create any elements with: " + name.toString() + ". " + this._debugInfo());
        }
        return lastChild;
    }
    /** @inheritdoc */
    remove() {
        const parent = this.up();
        parent.node.removeChild(this.node);
        return parent;
    }
    /** @inheritdoc */
    att(p1, p2, p3) {
        if (util_1.isMap(p1) || util_1.isObject(p1)) {
            // att(obj: AttributesObject)
            // expand if object
            util_1.forEachObject(p1, (attName, attValue) => this.att(attName, attValue), this);
            return this;
        }
        // get primitive values
        if (p1 !== undefined && p1 !== null)
            p1 = util_1.getValue(p1 + "");
        if (p2 !== undefined && p2 !== null)
            p2 = util_1.getValue(p2 + "");
        if (p3 !== undefined && p3 !== null)
            p3 = util_1.getValue(p3 + "");
        let namespace;
        let name;
        let value;
        if ((p1 === null || util_1.isString(p1)) && util_1.isString(p2) && (p3 === null || util_1.isString(p3))) {
            // att(namespace: string, name: string, value: string)
            [namespace, name, value] = [p1, p2, p3];
        }
        else if (util_1.isString(p1) && (p2 == null || util_1.isString(p2))) {
            // ele(name: string, value: string)
            [namespace, name, value] = [undefined, p1, p2];
        }
        else {
            throw new Error("Attribute name and value not specified. " + this._debugInfo());
        }
        if (this._options.keepNullAttributes && (value == null)) {
            // keep null attributes
            value = "";
        }
        else if (value == null) {
            // skip null|undefined attributes
            return this;
        }
        if (!util_2.Guard.isElementNode(this.node)) {
            throw new Error("An attribute can only be assigned to an element node.");
        }
        let ele = this.node;
        [namespace, name] = this._extractNamespace(namespace, name, false);
        name = dom_1.sanitizeInput(name, this._options.invalidCharReplacement);
        namespace = dom_1.sanitizeInput(namespace, this._options.invalidCharReplacement);
        value = dom_1.sanitizeInput(value, this._options.invalidCharReplacement);
        const [prefix, localName] = algorithm_1.namespace_extractQName(name);
        const [elePrefix, eleLocalName] = algorithm_1.namespace_extractQName(ele.prefix ? ele.prefix + ':' + ele.localName : ele.localName);
        // check if this is a namespace declaration attribute
        // assign a new element namespace if it wasn't previously assigned
        let eleNamespace = null;
        if (prefix === "xmlns") {
            namespace = infra_1.namespace.XMLNS;
            if (ele.namespaceURI === null && elePrefix === localName) {
                eleNamespace = value;
            }
        }
        else if (prefix === null && localName === "xmlns" && elePrefix === null) {
            namespace = infra_1.namespace.XMLNS;
            eleNamespace = value;
        }
        // re-create the element node if its namespace changed
        // we can't simply change the namespaceURI since its read-only
        if (eleNamespace !== null) {
            const newEle = algorithm_1.create_element(this._doc, eleLocalName, eleNamespace, elePrefix);
            for (const attr of ele.attributes) {
                newEle.setAttributeNodeNS(attr.cloneNode());
            }
            for (const childNode of ele.childNodes) {
                newEle.appendChild(childNode.cloneNode());
            }
            const parent = ele.parentNode;
            /* istanbul ignore next */
            if (parent === null) {
                throw new Error("Parent node is null." + this._debugInfo());
            }
            parent.replaceChild(newEle, ele);
            this._domNode = newEle;
            ele = newEle;
        }
        if (namespace !== undefined) {
            ele.setAttributeNS(namespace, name, value);
        }
        else {
            ele.setAttribute(name, value);
        }
        return this;
    }
    /** @inheritdoc */
    removeAtt(p1, p2) {
        if (!util_2.Guard.isElementNode(this.node)) {
            throw new Error("An attribute can only be removed from an element node.");
        }
        // get primitive values
        p1 = util_1.getValue(p1);
        if (p2 !== undefined) {
            p2 = util_1.getValue(p2);
        }
        let namespace;
        let name;
        if (p1 !== null && p2 === undefined) {
            name = p1;
        }
        else if ((p1 === null || util_1.isString(p1)) && p2 !== undefined) {
            namespace = p1;
            name = p2;
        }
        else {
            throw new Error("Attribute namespace must be a string. " + this._debugInfo());
        }
        if (util_1.isArray(name) || util_1.isSet(name)) {
            // removeAtt(names: string[])
            // removeAtt(namespace: string, names: string[])
            util_1.forEachArray(name, attName => namespace === undefined ? this.removeAtt(attName) : this.removeAtt(namespace, attName), this);
        }
        else if (namespace !== undefined) {
            // removeAtt(namespace: string, name: string)
            name = dom_1.sanitizeInput(name, this._options.invalidCharReplacement);
            namespace = dom_1.sanitizeInput(namespace, this._options.invalidCharReplacement);
            this.node.removeAttributeNS(namespace, name);
        }
        else {
            // removeAtt(name: string)
            name = dom_1.sanitizeInput(name, this._options.invalidCharReplacement);
            this.node.removeAttribute(name);
        }
        return this;
    }
    /** @inheritdoc */
    txt(content) {
        const child = this._doc.createTextNode(dom_1.sanitizeInput(content, this._options.invalidCharReplacement));
        this.node.appendChild(child);
        return this;
    }
    /** @inheritdoc */
    com(content) {
        const child = this._doc.createComment(dom_1.sanitizeInput(content, this._options.invalidCharReplacement));
        this.node.appendChild(child);
        return this;
    }
    /** @inheritdoc */
    dat(content) {
        const child = this._doc.createCDATASection(dom_1.sanitizeInput(content, this._options.invalidCharReplacement));
        this.node.appendChild(child);
        return this;
    }
    /** @inheritdoc */
    ins(target, content = '') {
        if (util_1.isArray(target) || util_1.isSet(target)) {
            util_1.forEachArray(target, item => {
                item += "";
                const insIndex = item.indexOf(' ');
                const insTarget = (insIndex === -1 ? item : item.substr(0, insIndex));
                const insValue = (insIndex === -1 ? '' : item.substr(insIndex + 1));
                this.ins(insTarget, insValue);
            }, this);
        }
        else if (util_1.isMap(target) || util_1.isObject(target)) {
            util_1.forEachObject(target, (insTarget, insValue) => this.ins(insTarget, insValue), this);
        }
        else {
            const child = this._doc.createProcessingInstruction(dom_1.sanitizeInput(target, this._options.invalidCharReplacement), dom_1.sanitizeInput(content, this._options.invalidCharReplacement));
            this.node.appendChild(child);
        }
        return this;
    }
    /** @inheritdoc */
    dec(options) {
        this._options.version = options.version || "1.0";
        this._options.encoding = options.encoding;
        this._options.standalone = options.standalone;
        return this;
    }
    /** @inheritdoc */
    dtd(options) {
        const name = dom_1.sanitizeInput((options && options.name) || (this._doc.documentElement ? this._doc.documentElement.tagName : "ROOT"), this._options.invalidCharReplacement);
        const pubID = dom_1.sanitizeInput((options && options.pubID) || "", this._options.invalidCharReplacement);
        const sysID = dom_1.sanitizeInput((options && options.sysID) || "", this._options.invalidCharReplacement);
        // name must match document element
        if (this._doc.documentElement !== null && name !== this._doc.documentElement.tagName) {
            throw new Error("DocType name does not match document element name.");
        }
        // create doctype node
        const docType = this._doc.implementation.createDocumentType(name, pubID, sysID);
        if (this._doc.doctype !== null) {
            // replace existing doctype
            this._doc.replaceChild(docType, this._doc.doctype);
        }
        else {
            // insert before document element node or append to end
            this._doc.insertBefore(docType, this._doc.documentElement);
        }
        return this;
    }
    /** @inheritdoc */
    import(node) {
        const hostNode = this._domNode;
        const hostDoc = this._doc;
        const importedNode = node.node;
        if (util_2.Guard.isDocumentNode(importedNode)) {
            // import document node
            const elementNode = importedNode.documentElement;
            if (elementNode === null) {
                throw new Error("Imported document has no document element node. " + this._debugInfo());
            }
            const clone = hostDoc.importNode(elementNode, true);
            hostNode.appendChild(clone);
        }
        else if (util_2.Guard.isDocumentFragmentNode(importedNode)) {
            // import child nodes
            for (const childNode of importedNode.childNodes) {
                const clone = hostDoc.importNode(childNode, true);
                hostNode.appendChild(clone);
            }
        }
        else {
            // import node
            const clone = hostDoc.importNode(importedNode, true);
            hostNode.appendChild(clone);
        }
        return this;
    }
    /** @inheritdoc */
    doc() {
        if (this._doc._isFragment) {
            let node = this.node;
            while (node && node.nodeType !== interfaces_2.NodeType.DocumentFragment) {
                node = node.parentNode;
            }
            /* istanbul ignore next */
            if (node === null) {
                throw new Error("Node has no parent node while searching for document fragment ancestor.");
            }
            return new XMLBuilderImpl(node);
        }
        else {
            return new XMLBuilderImpl(this._doc);
        }
    }
    /** @inheritdoc */
    root() {
        const ele = this._doc.documentElement;
        if (!ele) {
            throw new Error("Document root element is null. " + this._debugInfo());
        }
        return new XMLBuilderImpl(ele);
    }
    /** @inheritdoc */
    up() {
        const parent = this._domNode.parentNode;
        if (!parent) {
            throw new Error("Parent node is null. " + this._debugInfo());
        }
        return new XMLBuilderImpl(parent);
    }
    /** @inheritdoc */
    prev() {
        const node = this._domNode.previousSibling;
        if (!node) {
            throw new Error("Previous sibling node is null. " + this._debugInfo());
        }
        return new XMLBuilderImpl(node);
    }
    /** @inheritdoc */
    next() {
        const node = this._domNode.nextSibling;
        if (!node) {
            throw new Error("Next sibling node is null. " + this._debugInfo());
        }
        return new XMLBuilderImpl(node);
    }
    /** @inheritdoc */
    first() {
        const node = this._domNode.firstChild;
        if (!node) {
            throw new Error("First child node is null. " + this._debugInfo());
        }
        return new XMLBuilderImpl(node);
    }
    /** @inheritdoc */
    last() {
        const node = this._domNode.lastChild;
        if (!node) {
            throw new Error("Last child node is null. " + this._debugInfo());
        }
        return new XMLBuilderImpl(node);
    }
    /** @inheritdoc */
    each(callback, self = false, recursive = false, thisArg) {
        let result = this._getFirstDescendantNode(this._domNode, self, recursive);
        while (result[0]) {
            callback.call(thisArg, new XMLBuilderImpl(result[0]), result[1], result[2]);
            result = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);
        }
        return this;
    }
    /** @inheritdoc */
    map(callback, self = false, recursive = false, thisArg) {
        let result = [];
        this.each((node, index, level) => result.push(callback.call(thisArg, node, index, level)), self, recursive);
        return result;
    }
    /** @inheritdoc */
    reduce(callback, initialValue, self = false, recursive = false, thisArg) {
        let value = initialValue;
        this.each((node, index, level) => value = callback.call(thisArg, value, node, index, level), self, recursive);
        return value;
    }
    /** @inheritdoc */
    find(predicate, self = false, recursive = false, thisArg) {
        let result = this._getFirstDescendantNode(this._domNode, self, recursive);
        while (result[0]) {
            const builder = new XMLBuilderImpl(result[0]);
            if (predicate.call(thisArg, builder, result[1], result[2])) {
                return builder;
            }
            result = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);
        }
        return undefined;
    }
    /** @inheritdoc */
    filter(predicate, self = false, recursive = false, thisArg) {
        let result = [];
        this.each((node, index, level) => {
            if (predicate.call(thisArg, node, index, level)) {
                result.push(node);
            }
        }, self, recursive);
        return result;
    }
    /** @inheritdoc */
    every(predicate, self = false, recursive = false, thisArg) {
        let result = this._getFirstDescendantNode(this._domNode, self, recursive);
        while (result[0]) {
            const builder = new XMLBuilderImpl(result[0]);
            if (!predicate.call(thisArg, builder, result[1], result[2])) {
                return false;
            }
            result = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);
        }
        return true;
    }
    /** @inheritdoc */
    some(predicate, self = false, recursive = false, thisArg) {
        let result = this._getFirstDescendantNode(this._domNode, self, recursive);
        while (result[0]) {
            const builder = new XMLBuilderImpl(result[0]);
            if (predicate.call(thisArg, builder, result[1], result[2])) {
                return true;
            }
            result = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);
        }
        return false;
    }
    /** @inheritdoc */
    toArray(self = false, recursive = false) {
        let result = [];
        this.each(node => result.push(node), self, recursive);
        return result;
    }
    /** @inheritdoc */
    toString(writerOptions) {
        writerOptions = writerOptions || {};
        if (writerOptions.format === undefined) {
            writerOptions.format = "xml";
        }
        return this._serialize(writerOptions);
    }
    /** @inheritdoc */
    toObject(writerOptions) {
        writerOptions = writerOptions || {};
        if (writerOptions.format === undefined) {
            writerOptions.format = "object";
        }
        return this._serialize(writerOptions);
    }
    /** @inheritdoc */
    end(writerOptions) {
        writerOptions = writerOptions || {};
        if (writerOptions.format === undefined) {
            writerOptions.format = "xml";
        }
        return this.doc()._serialize(writerOptions);
    }
    /**
     * Gets the next descendant of the given node of the tree rooted at `root`
     * in depth-first pre-order. Returns a three-tuple with
     * [descendant, descendant_index, descendant_level].
     *
     * @param root - root node of the tree
     * @param self - whether to visit the current node along with child nodes
     * @param recursive - whether to visit all descendant nodes in tree-order or
     * only the immediate child nodes
     */
    _getFirstDescendantNode(root, self, recursive) {
        if (self)
            return [this._domNode, 0, 0];
        else if (recursive)
            return this._getNextDescendantNode(root, root, recursive, 0, 0);
        else
            return [this._domNode.firstChild, 0, 1];
    }
    /**
     * Gets the next descendant of the given node of the tree rooted at `root`
     * in depth-first pre-order. Returns a three-tuple with
     * [descendant, descendant_index, descendant_level].
     *
     * @param root - root node of the tree
     * @param node - current node
     * @param recursive - whether to visit all descendant nodes in tree-order or
     * only the immediate child nodes
     * @param index - child node index
     * @param level - current depth of the XML tree
     */
    _getNextDescendantNode(root, node, recursive, index, level) {
        if (recursive) {
            // traverse child nodes
            if (node.firstChild)
                return [node.firstChild, 0, level + 1];
            if (node === root)
                return [null, -1, -1];
            // traverse siblings
            if (node.nextSibling)
                return [node.nextSibling, index + 1, level];
            // traverse parent's next sibling
            let parent = node.parentNode;
            while (parent && parent !== root) {
                if (parent.nextSibling)
                    return [parent.nextSibling, algorithm_1.tree_index(parent.nextSibling), level - 1];
                parent = parent.parentNode;
                level--;
            }
        }
        else {
            if (root === node)
                return [node.firstChild, 0, level + 1];
            else
                return [node.nextSibling, index + 1, level];
        }
        return [null, -1, -1];
    }
    /**
     * Converts the node into its string or object representation.
     *
     * @param options - serialization options
     */
    _serialize(writerOptions) {
        if (writerOptions.format === "xml") {
            const writer = new writers_1.XMLWriter(this._options);
            return writer.serialize(this.node, writerOptions);
        }
        else if (writerOptions.format === "map") {
            const writer = new writers_1.MapWriter(this._options);
            return writer.serialize(this.node, writerOptions);
        }
        else if (writerOptions.format === "object") {
            const writer = new writers_1.ObjectWriter(this._options);
            return writer.serialize(this.node, writerOptions);
        }
        else if (writerOptions.format === "json") {
            const writer = new writers_1.JSONWriter(this._options);
            return writer.serialize(this.node, writerOptions);
        }
        else {
            throw new Error("Invalid writer format: " + writerOptions.format + ". " + this._debugInfo());
        }
    }
    /**
     * Creates a dummy element node without adding it to the list of child nodes.
     *
     * Dummy nodes are special nodes representing a node with a `null` value.
     * Dummy nodes are created while recursively building the XML tree. Simply
     * skipping `null` values doesn't work because that would break the recursive
     * chain.
     *
     * @returns the new dummy element node
     */
    _dummy() {
        return new XMLBuilderImpl(this._doc.createElement('dummy_node'));
    }
    /**
     * Extracts a namespace and name from the given string.
     *
     * @param namespace - namespace
     * @param name - a string containing both a name and namespace separated by an
     * '@' character
     * @param ele - `true` if this is an element namespace; otherwise `false`
     */
    _extractNamespace(namespace, name, ele) {
        // extract from name
        const atIndex = name.indexOf("@");
        if (atIndex > 0) {
            if (namespace === undefined)
                namespace = name.slice(atIndex + 1);
            name = name.slice(0, atIndex);
        }
        if (namespace === undefined) {
            // look-up default namespace
            namespace = (ele ? this._options.defaultNamespace.ele : this._options.defaultNamespace.att);
        }
        else if (namespace !== null && namespace[0] === "@") {
            // look-up namespace aliases
            const alias = namespace.slice(1);
            namespace = this._options.namespaceAlias[alias];
            if (namespace === undefined) {
                throw new Error("Namespace alias `" + alias + "` is not defined. " + this._debugInfo());
            }
        }
        return [namespace, name];
    }
    /**
     * Returns the document owning this node.
     */
    get _doc() {
        const node = this.node;
        if (util_2.Guard.isDocumentNode(node)) {
            return node;
        }
        else {
            const docNode = node.ownerDocument;
            /* istanbul ignore next */
            if (!docNode)
                throw new Error("Owner document is null. " + this._debugInfo());
            return docNode;
        }
    }
    /**
     * Returns debug information for this node.
     *
     * @param name - node name
     */
    _debugInfo(name) {
        const node = this.node;
        const parentNode = node.parentNode;
        name = name || node.nodeName;
        const parentName = parentNode ? parentNode.nodeName : '';
        if (!parentName) {
            return "node: <" + name + ">";
        }
        else {
            return "node: <" + name + ">, parent: <" + parentName + ">";
        }
    }
    /**
     * Gets or sets builder options.
     */
    get _options() {
        const doc = this._doc;
        /* istanbul ignore next */
        if (doc._xmlBuilderOptions === undefined) {
            throw new Error("Builder options is not set.");
        }
        return doc._xmlBuilderOptions;
    }
    set _options(value) {
        const doc = this._doc;
        doc._xmlBuilderOptions = value;
    }
}
exports.XMLBuilderImpl = XMLBuilderImpl;
//# sourceMappingURL=XMLBuilderImpl.js.map