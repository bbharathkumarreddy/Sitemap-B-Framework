"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const interfaces_1 = require("./interfaces");
const util_1 = require("@oozcitak/util");
const util_2 = require("@oozcitak/dom/lib/util");
const builder_1 = require("./builder");
const dom_1 = require("./builder/dom");
const util_3 = require("util");
const builder_2 = require("./builder");
/** @inheritdoc */
function builder(p1, p2) {
    const options = formatBuilderOptions(isXMLBuilderCreateOptions(p1) ? p1 : interfaces_1.DefaultBuilderOptions);
    const nodes = util_2.Guard.isNode(p1) || util_3.isArray(p1) ? p1 : p2;
    if (nodes === undefined) {
        throw new Error("Invalid arguments.");
    }
    if (util_3.isArray(nodes)) {
        const builders = [];
        for (let i = 0; i < nodes.length; i++) {
            const builder = new builder_1.XMLBuilderImpl(nodes[i]);
            builder.set(options);
            builders.push(builder);
        }
        return builders;
    }
    else {
        const builder = new builder_1.XMLBuilderImpl(nodes);
        builder.set(options);
        return builder;
    }
}
exports.builder = builder;
/** @inheritdoc */
function create(p1, p2) {
    const options = formatBuilderOptions(p1 === undefined || isXMLBuilderCreateOptions(p1) ?
        p1 : interfaces_1.DefaultBuilderOptions);
    const contents = isXMLBuilderCreateOptions(p1) ? p2 : p1;
    let builder;
    if (contents === undefined) {
        // empty document
        const doc = dom_1.createDocument();
        builder = new builder_1.XMLBuilderImpl(doc);
        setOptions(doc, options);
    }
    else if (util_1.isObject(contents)) {
        // JS object
        const doc = dom_1.createDocument();
        builder = new builder_1.XMLBuilderImpl(doc);
        setOptions(doc, options);
        builder.ele(contents);
    }
    else if (/^\s*</.test(contents)) {
        // XML document
        const domParser = dom_1.createParser();
        const doc = domParser.parseFromString(dom_1.sanitizeInput(contents, options.invalidCharReplacement), "text/xml");
        dom_1.throwIfParserError(doc);
        builder = new builder_1.XMLBuilderImpl(doc);
        setOptions(doc, options);
    }
    else {
        // JSON
        const doc = dom_1.createDocument();
        builder = new builder_1.XMLBuilderImpl(doc);
        setOptions(doc, options);
        const obj = JSON.parse(contents);
        builder.ele(obj);
    }
    return builder;
}
exports.create = create;
/** @inheritdoc */
function fragment(p1, p2) {
    const options = formatBuilderOptions(p1 === undefined || isXMLBuilderCreateOptions(p1) ?
        p1 : interfaces_1.DefaultBuilderOptions);
    const contents = isXMLBuilderCreateOptions(p1) ? p2 : p1;
    let builder;
    if (contents === undefined) {
        // empty fragment
        const doc = dom_1.createDocument();
        setOptions(doc, options, true);
        builder = new builder_1.XMLBuilderImpl(doc.createDocumentFragment());
    }
    else if (util_1.isObject(contents)) {
        // JS object
        const doc = dom_1.createDocument();
        setOptions(doc, options, true);
        builder = new builder_1.XMLBuilderImpl(doc.createDocumentFragment());
        builder.ele(contents);
    }
    else if (/^\s*</.test(contents)) {
        // XML document
        const domParser = dom_1.createParser();
        const doc = domParser.parseFromString("<TEMP_ROOT>" +
            dom_1.sanitizeInput(contents, options.invalidCharReplacement) + "</TEMP_ROOT>", "text/xml");
        dom_1.throwIfParserError(doc);
        setOptions(doc, options, true);
        /* istanbul ignore next */
        if (doc.documentElement === null) {
            throw new Error("Document element is null.");
        }
        const frag = doc.createDocumentFragment();
        for (const child of doc.documentElement.childNodes) {
            const newChild = doc.importNode(child, true);
            frag.appendChild(newChild);
        }
        builder = new builder_1.XMLBuilderImpl(frag);
    }
    else {
        // JSON
        const doc = dom_1.createDocument();
        setOptions(doc, options, true);
        builder = new builder_1.XMLBuilderImpl(doc.createDocumentFragment());
        const obj = JSON.parse(contents);
        builder.ele(obj);
    }
    return builder;
}
exports.fragment = fragment;
/** @inheritdoc */
function convert(p1, p2, p3) {
    let builderOptions;
    let contents;
    let convertOptions;
    if (isXMLBuilderCreateOptions(p1) && p2 !== undefined) {
        builderOptions = p1;
        contents = p2;
        convertOptions = p3;
    }
    else {
        builderOptions = interfaces_1.DefaultBuilderOptions;
        contents = p1;
        convertOptions = p2 || undefined;
    }
    return create(builderOptions, contents).end(convertOptions);
}
exports.convert = convert;
/**
 * Creates an XML builder which serializes the document in chunks.
 *
 * @param options - callback builder options
 *
 * @returns callback builder
 */
function createCB(options) {
    return new builder_2.XMLBuilderCBImpl(options);
}
exports.createCB = createCB;
/**
 * Creates an XML builder which serializes the fragment in chunks.
 *
 * @param options - callback builder options
 *
 * @returns callback builder
 */
function fragmentCB(options) {
    return new builder_2.XMLBuilderCBImpl(options, true);
}
exports.fragmentCB = fragmentCB;
function isXMLBuilderCreateOptions(obj) {
    if (!util_1.isPlainObject(obj))
        return false;
    for (const key in obj) {
        /* istanbul ignore else */
        if (obj.hasOwnProperty(key)) {
            if (!interfaces_1.XMLBuilderOptionKeys.has(key))
                return false;
        }
    }
    return true;
}
function formatBuilderOptions(createOptions = {}) {
    const options = util_1.applyDefaults(createOptions, interfaces_1.DefaultBuilderOptions);
    if (options.convert.att.length === 0 ||
        options.convert.ins.length === 0 ||
        options.convert.text.length === 0 ||
        options.convert.cdata.length === 0 ||
        options.convert.comment.length === 0) {
        throw new Error("JS object converter strings cannot be zero length.");
    }
    return options;
}
function setOptions(doc, options, isFragment) {
    const docWithSettings = doc;
    docWithSettings._xmlBuilderOptions = options;
    docWithSettings._isFragment = isFragment;
}
//# sourceMappingURL=index.js.map